def get_mod_name_from_zip(zip_path):
    try:
        with zipfile.ZipFile(zip_path, 'r') as zipf:
            for item in zipf.namelist():
                if item.endswith('info.json'):
                    with zipf.open(item) as f:
                        info = json.load(f)
                        return info.get('name')
    except Exception:
        pass
    return None
import os
import zipfile
import tempfile
import re
import requests
import json
import shutil
from pathlib import Path
from datetime import datetime

def find_locale_files(zip_path):
    try:
        with zipfile.ZipFile(zip_path, 'r') as zipf:
            namelist = zipf.namelist()
            if not namelist:
                return None, []
            root_folder = None
            for item in namelist:
                if 'info.json' in item and item.count('/') == 1:
                    root_folder = item.split('/')[0]
                    break
            if root_folder is None:
                for item in namelist:
                    if '/' in item:
                        root_folder = item.split('/')[0]
                        break
            if root_folder is None:
                return None, []
            search_prefix = f"{root_folder}/locale/en/"
            locale_files = [f for f in namelist if f.startswith(search_prefix) and f.endswith(".cfg")]
            return root_folder, locale_files
    except zipfile.BadZipFile:
        return None, []
    except Exception:
        return None, []

def read_cfg_file(zipf, file_path):
    with zipf.open(file_path) as f:
        content = f.read()
        try:
            return content.decode('utf-8')
        except UnicodeDecodeError:
            return content.decode('utf-8-sig')

def write_cfg_file(content_lines, dest_path):
    dest_path.parent.mkdir(parents=True, exist_ok=True)
    with open(dest_path, "w", encoding="utf-8") as f:
        f.writelines(content_lines)

def translate_texts(texts, deepl_api_key, target_lang, glossary_id=None):
    if not texts:
        return []
    data = {
        "auth_key": deepl_api_key,
        "text": texts,
        "target_lang": target_lang,
        "tag_handling": "xml"
    }
    if glossary_id:
        data["glossary_id"] = glossary_id
    response = requests.post(
        "https://api-free.deepl.com/v2/translate",
        data=data
    )
    response.raise_for_status()
    translated = [line["text"] for line in response.json()["translations"]]
    return translated

def parse_cfg_lines(raw_text):
    lines = raw_text.splitlines(keepends=True)
    key_val_lines = []
    for i, line in enumerate(lines):
        stripped = line.strip()
        if "=" in stripped and not stripped.startswith(";"):
            key, val = re.split(r'=', stripped, 1)
            key_val_lines.append({'index': i, 'key': key.strip(), 'val': val.strip()})
    return key_val_lines, lines

def prepare_mod_structure(mod_name, mod_sample_dir, output_dir, lang_code):
    # Copy mod sample structure to output_dir/mod_name
    mod_out_dir = Path(output_dir) / mod_name
    if not mod_out_dir.exists():
        shutil.copytree(mod_sample_dir, mod_out_dir)
    # Không xóa locale_dir, chỉ tạo nếu chưa có
    locale_dir = mod_out_dir / 'locale' / lang_code
    locale_dir.mkdir(parents=True, exist_ok=True)
    return mod_out_dir, locale_dir

def update_info_json(info_path, mod_name, lang_code, mod_list):
    with open(info_path, encoding='utf-8') as f:
        info = json.load(f)
    # Đặt version theo ngày nếu chưa có, hoặc giữ nguyên nếu đã có
    version = info.get('version') or datetime.now().strftime('%Y.%m.%d')
    info['version'] = version
    info['name'] = f"{mod_name}_{version}"
    info['title'] = f"Factorio Planet Mods Vietnamese Language Pack"
    info['author'] = "Hoang0109 - hoang0109@gmail.com"
    info['description'] = f"Gói việt hóa cho các mod hành tinh Factorio. Bao gồm: {', '.join(mod_list)}.\nTự động dịch bằng DeepL, có thể cần chỉnh sửa thủ công."
    info['factorio_version'] = "2.0"
    # Giữ lại dependencies cũ, chỉ thêm mới nếu chưa có
    old_deps = set()
    if 'dependencies' in info:
        for dep in info['dependencies']:
            dep_name = dep.strip().lstrip('?').strip()
            old_deps.add(dep_name)
    for mod in mod_list:
        if mod not in old_deps:
            old_deps.add(mod)
    info['dependencies'] = [f"? {mod}" for mod in sorted(old_deps)]
    with open(info_path, 'w', encoding='utf-8') as f:
        json.dump(info, f, ensure_ascii=False, indent=2)

def update_changelog(changelog_path, mod_list):
    now = datetime.now()
    new_entry = f"{'-'*99}\nVersion: {now.strftime('%Y.%m.%d')}\nDate: {now.strftime('%Y.%m.%d')}\n  Update:\n    - " + '\n    - '.join(mod_list) + '\n  Note: Auto-generated by Mod Translator.\n'
    with open(changelog_path, encoding='utf-8') as f:
        old = f.read()
    with open(changelog_path, 'w', encoding='utf-8') as f:
        f.write(new_entry + old)

def process_mods_to_language_pack(mod_paths, mod_sample_dir, output_dir, deepl_api_key, target_lang, lang_code, glossary_id=None):
    # Đặt version theo ngày nếu chưa có, hoặc lấy từ info.json mẫu
    info_json_path = Path(mod_sample_dir) / 'info.json'
    if info_json_path.exists():
        with open(info_json_path, encoding='utf-8') as f:
            info = json.load(f)
        version = info.get('version') or datetime.now().strftime('%Y.%m.%d')
    else:
        version = datetime.now().strftime('%Y.%m.%d')
    mod_name = f"Translate_planet_into_Vietnamese_{version}"
    mod_out_dir, locale_dir = prepare_mod_structure(mod_name, mod_sample_dir, output_dir, lang_code)
    mod_list = []
    total = len(mod_paths)
    for idx, mod_path in enumerate(mod_paths):
        mod_real_name = get_mod_name_from_zip(mod_path)
        if not mod_real_name:
            continue
        root_folder, locale_files = find_locale_files(mod_path)
        if not root_folder or not locale_files:
            continue
        with zipfile.ZipFile(mod_path, 'r') as zipf:
            for locale_file in locale_files:
                raw_text = read_cfg_file(zipf, locale_file)
                key_vals, lines = parse_cfg_lines(raw_text)
                values_to_translate = [item['val'] for item in key_vals]
                if not values_to_translate:
                    continue
                try:
                    translated_texts = translate_texts(values_to_translate, deepl_api_key, target_lang, glossary_id)
                    if len(translated_texts) != len(values_to_translate):
                        continue
                except Exception:
                    continue
                translated_iter = iter(translated_texts)
                translated_lines = lines[:]
                for item in key_vals:
                    translated_val = next(translated_iter)
                    translated_lines[item['index']] = f"{item['key']}={translated_val}\n"
                # Đặt tên file là tên mod, chỉ ghi đè file này, không xóa file khác
                out_path = locale_dir / f"{mod_real_name}.cfg"
                write_cfg_file(translated_lines, out_path)
            mod_list.append(mod_real_name)
        # Gọi callback tiến độ nếu có
        if 'progress_callback' in locals() or 'progress_callback' in globals():
            try:
                progress_callback = locals().get('progress_callback') or globals().get('progress_callback')
                if progress_callback:
                    progress_callback(idx+1, total, mod_real_name)
            except Exception:
                pass
    # Update info.json, changelog.txt
    update_info_json(mod_out_dir / 'info.json', mod_name, lang_code, mod_list)
    update_changelog(mod_out_dir / 'changelog.txt', mod_list)
    return mod_out_dir
